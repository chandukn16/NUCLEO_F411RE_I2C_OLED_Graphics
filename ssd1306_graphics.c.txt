/*
 * ssd1306_graphics.c
 *
 * Simple graphics primitives implementation that uses the SSD1306 API.
 *
 * These routines call SSD1306_DrawPixel() for each pixel and therefore are
 * not the most efficient possible, but are simple to integrate.
 *
 * After drawing, call SSD1306_UpdateScreen() to present changes.
 */

#include "ssd1306_graphics.h"
#include <stdlib.h> /* for abs */

/* Bresenham's line algorithm */
void SSD1306_DrawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint8_t color)
{
    int16_t dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    int16_t dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    int16_t err = dx + dy, e2;

    while (1) {
        if (x0 >= 0 && x0 < SSD1306_WIDTH && y0 >= 0 && y0 < SSD1306_HEIGHT)
            SSD1306_DrawPixel((uint8_t)x0, (uint8_t)y0, color);
        if (x0 == x1 && y0 == y1) break;
        e2 = 2 * err;
        if (e2 >= dy) {
            err += dy;
            x0 += sx;
        }
        if (e2 <= dx) {
            err += dx;
            y0 += sy;
        }
    }
}

/* Rectangle outline */
void SSD1306_DrawRect(int16_t x, int16_t y, int16_t w, int16_t h, uint8_t color)
{
    if (w <= 0 || h <= 0) return;
    SSD1306_DrawLine(x, y, x + w - 1, y, color);
    SSD1306_DrawLine(x, y + h - 1, x + w - 1, y + h - 1, color);
    SSD1306_DrawLine(x, y, x, y + h - 1, color);
    SSD1306_DrawLine(x + w - 1, y, x + w - 1, y + h - 1, color);
}

/* Filled rectangle (draw horizontal lines) */
void SSD1306_FillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint8_t color)
{
    if (w <= 0 || h <= 0) return;
    for (int16_t j = y; j < y + h; j++) {
        SSD1306_DrawLine(x, j, x + w - 1, j, color);
    }
}

/* Midpoint circle algorithm - outline */
void SSD1306_DrawCircle(int16_t x0, int16_t y0, int16_t r, uint8_t color)
{
    if (r <= 0) return;
    int16_t x = 0;
    int16_t y = r;
    int16_t f = 1 - r;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;

    /* Initial points */
    if (x0 >= 0 && x0 < SSD1306_WIDTH && (y0 + r) >= 0 && (y0 + r) < SSD1306_HEIGHT)
        SSD1306_DrawPixel((uint8_t)x0, (uint8_t)(y0 + r), color);
    if (x0 >= 0 && x0 < SSD1306_WIDTH && (y0 - r) >= 0 && (y0 - r) < SSD1306_HEIGHT)
        SSD1306_DrawPixel((uint8_t)x0, (uint8_t)(y0 - r), color);
    if ((x0 + r) >= 0 && (x0 + r) < SSD1306_WIDTH && y0 >= 0 && y0 < SSD1306_HEIGHT)
        SSD1306_DrawPixel((uint8_t)(x0 + r), (uint8_t)y0, color);
    if ((x0 - r) >= 0 && (x0 - r) < SSD1306_WIDTH && y0 >= 0 && y0 < SSD1306_HEIGHT)
        SSD1306_DrawPixel((uint8_t)(x0 - r), (uint8_t)y0, color);

    while (x < y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
        }
        x++;
        ddF_x += 2;
        f += ddF_x;

        /* Octants */
        if ((x0 + x) >= 0 && (x0 + x) < SSD1306_WIDTH) {
            if ((y0 + y) >= 0 && (y0 + y) < SSD1306_HEIGHT) SSD1306_DrawPixel((uint8_t)(x0 + x), (uint8_t)(y0 + y), color);
            if ((y0 - y) >= 0 && (y0 - y) < SSD1306_HEIGHT) SSD1306_DrawPixel((uint8_t)(x0 + x), (uint8_t)(y0 - y), color);
        }
        if ((x0 - x) >= 0 && (x0 - x) < SSD1306_WIDTH) {
            if ((y0 + y) >= 0 && (y0 + y) < SSD1306_HEIGHT) SSD1306_DrawPixel((uint8_t)(x0 - x), (uint8_t)(y0 + y), color);
            if ((y0 - y) >= 0 && (y0 - y) < SSD1306_HEIGHT) SSD1306_DrawPixel((uint8_t)(x0 - x), (uint8_t)(y0 - y), color);
        }
        if ((x0 + y) >= 0 && (x0 + y) < SSD1306_WIDTH) {
            if ((y0 + x) >= 0 && (y0 + x) < SSD1306_HEIGHT) SSD1306_DrawPixel((uint8_t)(x0 + y), (uint8_t)(y0 + x), color);
            if ((y0 - x) >= 0 && (y0 - x) < SSD1306_HEIGHT) SSD1306_DrawPixel((uint8_t)(x0 + y), (uint8_t)(y0 - x), color);
        }
        if ((x0 - y) >= 0 && (x0 - y) < SSD1306_WIDTH) {
            if ((y0 + x) >= 0 && (y0 + x) < SSD1306_HEIGHT) SSD1306_DrawPixel((uint8_t)(x0 - y), (uint8_t)(y0 + x), color);
            if ((y0 - x) >= 0 && (y0 - x) < SSD1306_HEIGHT) SSD1306_DrawPixel((uint8_t)(x0 - y), (uint8_t)(y0 - x), color);
        }
    }
}

/* Filled circle - draw vertical lines between symmetric points */
void SSD1306_FillCircle(int16_t x0, int16_t y0, int16_t r, uint8_t color)
{
    if (r <= 0) return;
    int16_t x = 0;
    int16_t y = r;
    int16_t f = 1 - r;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;

    /* Draw initial vertical line */
    SSD1306_DrawLine(x0, y0 - r, x0, y0 + r, color);

    while (x < y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
        }
        x++;
        ddF_x += 2;
        f += ddF_x;

        /* Draw vertical lines between the symmetric points */
        if (x0 + x >= 0 && x0 + x < SSD1306_WIDTH) {
            SSD1306_DrawLine(x0 + x, y0 - y, x0 + x, y0 + y, color);
        }
        if (x0 - x >= 0 && x0 - x < SSD1306_WIDTH) {
            SSD1306_DrawLine(x0 - x, y0 - y, x0 - x, y0 + y, color);
        }
        if (x0 + y >= 0 && x0 + y < SSD1306_WIDTH) {
            SSD1306_DrawLine(x0 + y, y0 - x, x0 + y, y0 + x, color);
        }
        if (x0 - y >= 0 && x0 - y < SSD1306_WIDTH) {
            SSD1306_DrawLine(x0 - y, y0 - x, x0 - y, y0 + x, color);
        }
    }
}

/* Draw 1-bit bitmap (rows packed MSB-first). For each pixel set bit -> draw color; cleared bit -> don't change or draw background.
   If you want background erasing, call SSD1306_FillRect(x,y,bw,bh,0) before.
*/
void SSD1306_DrawBitmapXY(int16_t x, int16_t y, const uint8_t *bitmap, int16_t bw, int16_t bh, uint8_t color)
{
    if (!bitmap) return;
    int bytes_per_row = (bw + 7) / 8;
    for (int row = 0; row < bh; row++) {
        for (int col = 0; col < bw; col++) {
            int byte_index = row * bytes_per_row + (col / 8);
            uint8_t b = bitmap[byte_index];
            uint8_t bit = 0x80 >> (col & 7); /* MSB first */
            if (b & bit) {
                int16_t px = x + col;
                int16_t py = y + row;
                if (px >= 0 && px < SSD1306_WIDTH && py >= 0 && py < SSD1306_HEIGHT)
                    SSD1306_DrawPixel((uint8_t)px, (uint8_t)py, color);
            }
        }
    }
}
